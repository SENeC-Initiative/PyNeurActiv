#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" Computing the theoretical properties of the bursting dynamics """

from collections import namedtuple
from six import add_metaclass
import warnings

import numpy as np
from scipy.integrate import quad
from scipy.optimize import brentq
from scipy.special import lambertw

from pyneuractiv.analysis import find_idx_nearest
import pyneuractiv.lib as _plib


#-----------------------------------------------------------------------------#
# Computing the values
#------------------------
#

@add_metaclass(_plib.ResNames)
class Fardet2017_SynchroBurst:

    ''' Class computing the theoretical values '''

    _res_names = ('burst_duration', 'IBI', 'ISI', 'w_min', 'w_max', 'V_min',
                  'SpB')

    @staticmethod
    def help():
        print('''
Help for the TheoreticalModel class
-----------------------------------

Initialization with a dictionary containing the usual entries for a NEST
"aeif_cond_alpha" model, as well as 4 additional entries ("model", "weight",
"avg_deg", and "delay" -- see ``__init__`` docstring for details).

Ex: ``theo = TheoreticalModel(di_param)``

Goal
----

Compute the properties of the bursting dynamics of coupled aEIF neurons for
various synaptic models ("dirac", "continuous" or "alpha").


Relevant functions
------------------

* ``theo.compute_properties(model=model_of_choice)``: compute all relevant
    properties of the bursting dynamics
* ``theo.plot_time_evol(model=model_of_choice)``: plot the time evolution of
    the model.


* ``theo.w_max(model=model_of_choice)``: use a self-coherent equation to
    compute the maximal value of the adaptation variable `w` at the end of a
    burst.
* ``theo.IBI(w_max)``: computes the interburst interval for a given `w_max`. If
    no `w_max` is given, a "model" can be provided to compute it automatically,
    using ``theo.IBI(model=model_of_choice)``.
* ``theo.T_spike(w, model=model_of_choice)``: function computing the interspike
    for a given value of `w`. Depending on the model, additional parameters
    might be provided, see doctrings.
* ``theo.burst_duration(model=model_of_choice)``: returns burst duration
''')

    @classmethod
    def from_nest_network(cls, gids, ignore_errors=False, verbose=False):
        '''
        Generate the theoretical values computed from neurons in a network
        generated by NEST.

        .. todo ::
            Find a way to get the weights

        Args:
        gids : tuple
            Indices of the neurons in NEST.

        Returns:
        Instance of :class:`TheoreticalModel``.
        '''
        import nest
        di_status = nest.GetStatus([gids[0]])[0]
        connections = nest.GetConnections()
        di_status["avg_deg"] = len(connections) / float(len(gids))
        connection = (connections[0],)
        if not connection:
            raise RuntimeError("No connections in the network.")
        di_status.update(nest.GetStatus(connection)[0])
        return cls(di_status, ignore_errors=ignore_errors, verbose=verbose)

    #--------------------------------------------------------------------------
    # Init and compute

    def __init__(self, di_prop, ignore_errors=False, verbose=False):
        '''
        Prepare all the dimensionless values from the dictionnary `di_prop`
        containing the parameters.

        `di_prop` must contain:

        * all neuronal parameters for the NEST aeif model
        * a ``"model"`` entry with model name in NEST, e.g. "aeif_psc_alpha"
        * a ``"weight"`` entry giving the synaptic strength in pA
        * an ``"avg_deg"`` entry giving average number of neighbours
        * a ``"delay"`` entry giving the synaptic delay
        '''
        self._prop = di_prop
        if "tau_m" not in di_prop:
            self._prop["tau_m"] = di_prop["C_m"]/di_prop["g_L"]
        self.dimT = self._prop["tau_m"]
        self.DT_dim = self._prop["Delta_T"]
        self.Vt_dim = self._prop["V_th"]
        self.dimW = self._prop["g_L"]*self._prop["Delta_T"]
        model_name = str(di_prop["model"])
        if model_name.find("aeif") == -1:
            raise RuntimeError("Model should be of type 'aeif_*' neurons.")
        dimensionless_prop = _plib.adim_dict(self._prop)
        self._adim_params = dimensionless_prop
        self._generate_values(dimensionless_prop)
        self._res = {res: 0. for res in self.__class__.result_names}
        self.TheoResults = namedtuple("TheoResults", list(self._res.keys()))
        # values containing informations about the object state
        self._computed = False
        self._ignore_errors = ignore_errors
        self.verbose = verbose
        if not verbose:
            warnings.filterwarnings('ignore')

    #--------------------------------------------------------------------------
    # Main functions

    def compute_properties(self, model="alpha", adim=False):
        '''
        Compute the following properties of the bursting dynamics:

        * "w_max" (maximum value of `w` at the end of a burst)
        * "w_min" (minimal value of `w` juste before a burst starts)
        * "SpB" (spikes per burst, number of spikes in a burst)
        * "ISI" (interspike interval inside the burst)
        * "burst_duration" (burst duration)
        * "IBI" (inter-burst interval)

        Args:
        model (:obj:`str`):ing, optional (default: "alpha")
            Synaptic model to use.
        adim (bool, optional, default: False): Whether the results should be dimensionless or not.

        Returns:
        namedtuple containing the aforementionned values.
        '''
        w_min = self.w_minus(adim=True)
        self._res["w_min"] = w_min
        try :
            w_max = self.w_max(model=model, adim=True)
        except Exception as e:
            if self._ignore_errors:
                if self.verbose:
                    print("{}: {}".format(e.__class__.__name__, e))
                w_max = np.NaN
            else:
                raise
        #~ if np.isnan(w_max):
            #~ print("w_max is NAN!")
        V_max = self.V_end_burst(w_max, model=model, adim=True)
        self._res["w_max"] = w_max
        self._res["V_min"] = self.V_down(w_max, V_max, adim=True)
        self._computed = True
        self._res["SpB"] = self.SpB(model=model, adim=True)
        I = self.Ie + (w_max - w_min) if model == "continuous" else None
        self._res["ISI"] = self.avg_ISI(w_max, I=I, model=model, adim=True)
        self._res["burst_duration"] = self.burst_duration(
            model=model, adim=True)
        self._res["IBI"] = self.IBI(w_max, model=model, adim=True)
        # check for NaNs
        contains_NaN = False
        for key, val in self._res.items():
            contains_NaN = True if np.isnan(val) else contains_NaN
            if np.isnan(val) and not np.isnan(w_max):
                print(key + " is NAN!")
        if contains_NaN:
            for key in self._res:
                self._res[key] = np.NaN
        self._res_dim = _plib.redim_dict(self._res, self._prop)
        if adim:
            return self.TheoResults(**self._res)
        else:
            return self.TheoResults(**self._res_dim)


    def results(self, adim=False):
        if adim:
            return self.TheoResults(**self._res)
        else:
            return self.TheoResults(**self._res_dim)


    def set_properties(self, dic):
        '''
        Change the values of the properties.
        '''
        for key in dic:
            assert key in self._prop, "Invalid key {}".format(key)
        self._prop.update(dic)
        if "tau_m" not in dic:
            if "C_m" in dic and "g_L" in dic:
                self._prop["tau_m"] = dic["C_m"] / dic["g_L"]
            elif "C_m" in dic:
                self._prop["tau_m"] = dic["C_m"] / self._prop["g_L"]
            elif "g_L" in dic:
                self._prop["tau_m"] = self._prop["C_m"] / dic["g_L"]
        self.dimT = self._prop["tau_m"]
        self.DT_dim = self._prop["Delta_T"]
        self.Vt_dim = self._prop["V_th"]
        self.dimW = self._prop["g_L"]*self._prop["Delta_T"]
        model_name = str(self._prop["model"])
        if model_name.find("aeif") == -1:
            raise RuntimeError("Model should be of type 'aeif_*' neurons.")
        dimensionless_prop = _plib.adim_dict(self._prop)
        self._adim_params = dimensionless_prop
        self._generate_values(dimensionless_prop)
        self._computed = False
        for key in self._res:
            self._res[key] = 0.


    def time_evolution(self, model="alpha", num_bursts=3, steps=1000,
                       synchronous=False, adim=False, show=True):
        '''
        Plot the time evolution of the V and w variables for the theoretical
        mean-field model.

        Args:
            model (:obj:`str`, optional, default: "dirac"):  Model to use for
                 the synapses among "dirac", "continuous" and "alpha".
            num_bursts (int, optional, default: 3): Number of bursts to model.
            steps (int, optional, default: 1000): Number of steps taken to
                model each time interval (initial decrease of V, recovery
                period and bursting period; default is 1000).
            adim (bool, optional, default: False): Whether the variables should
                be given in dimensionless units.
            show (bool, optional, default: True): Whether the results should be
                displayed.

        Returns:
            ts, Vs, ws, stimes (numpy arrays): time, voltage, and adaptation
                variables, as well as the spike times.
        '''
        ts_tmp, Vs_tmp, ws_tmp = [0.], [], []
        ts, Vs, ws, stimes = [], [], [], []
        # w & V critical values
        w_max = self.w_max(model=model, synchronous=synchronous, adim=adim)
        V_max, t_max = self.V_end_burst(
            w_max, model=model, return_time=True, adim=adim)
        for i in range(num_bursts):
            # V & w down
            if model in ("alpha", "dirac"):
                ts.append(ts_tmp[-1] + np.nextafter(t_max, t_max-1))
                Vs.append(V_max)
                ws.append(w_max)
            start = ts_tmp[-1] + t_max
            ts_tmp, Vs_tmp = self._func_Vdown(
                w_max, V_max, steps, start=start, adim=adim)
            _, ws_tmp = self._func_wdown(
                w_max, V_max, ts_tmp, start=start, adim=adim)
            ts.extend(ts_tmp)
            Vs.extend(Vs_tmp)
            ws.extend(ws_tmp)
            # recovery start
            ts_tmp, ws_tmp = self._func_w_recover_start(
                ws[-1], w_max, V_max, start=ts[-1], adim=adim)
            Vs_tmp = self._func_V_recover_start(
                ts_tmp, ws[-1], w_max, V_max, adim=adim)
            ts.extend(ts_tmp)
            Vs.extend(Vs_tmp)
            ws.extend(ws_tmp)
            # recovery
            ts_tmp, ws_tmp = self._func_w_recover(
                ws[-1], Vs[-1], w_max, V_max, steps, start=ts_tmp[-1],
                adim=adim)
            Vs_tmp = self._func_V_recover(ws_tmp, Vs[-1], adim=adim)
            ts.extend(ts_tmp)
            Vs.extend(Vs_tmp)
            ws.extend(ws_tmp)
            # burst
            ts_tmp, ws_tmp, st_tmp = self._func_w_burst(
                ws[-1], ts[-1], steps, model=model, synchronous=synchronous,
                adim=adim)
            stimes.extend(st_tmp + ts[-1])
            ts.extend(ts_tmp)
            Vs.extend(np.repeat(np.NaN, len(ts_tmp)))
            ws.extend(ws_tmp)
        if show:
            import matplotlib.pyplot as plt
            fig, (ax1, ax2) = plt.subplots(2, sharex=True)
            ax1.plot(ts, Vs)
            ax2.plot(ts, ws)
            V_spike = (theo.Vp / 2. if adim
                       else (self.Vt_dim + self._prop["V_peak"]) / 2.)
            ax1.scatter(stimes, np.repeat(V_spike, len(stimes)))
            plt.show()
        return np.array(ts), np.array(Vs), np.array(ws), np.array(stimes)


    #---------------------------------------------------------------------------
    # Get characteristic values

    def w_max(self, model="alpha", w_lim=None, synchronous=False, adim=False):
        '''
        Return the critical value for w (at which the burst stops).

        Args:
            model (:obj:`str`, optional, default: "alpha"): Name of the
                synaptic model that should be used, among "dirac",
                "continuous", and "alpha".
            w_lim (double):, optional (default: None)
                Higher limit for w_max when using the "alpha" model.
            synchronous (bool, optional, default: False): Whether we should
                return the exact dynamics for a network of synchronous neurons
                or a smoothed mean-field dynamics for a heterogeneous network.
            adim (bool, optional, default: True):
                Whether the results should be dimensionless or not.

        Returns:
            w_max (double): the maximum value of w at the end of a burst.
        '''
        # check that the neurons are out of equilibrium
        out_of_eq = _plib.out_of_eq_aeif(self._adim_params)
        if out_of_eq:
            w_min, sce = self.w_minus(adim=True), None
            dim = 1. if adim else self.dimW
            if model == "alpha":
                def sce_alpha(w):
                    return self.rhs_sce_alpha(w, adim=True) - w
                sce = sce_alpha
                w_lim = w_min + 30*self.b if w_lim is None else w_lim
            elif model == "continuous":
                def sce_continuous(w):
                    return self.rhs_sce_continuous(w, adim=True) - w
                sce = sce_continuous
                w_lim = self.Imax if w_lim is None else w_lim
            else:
                def sce_dirac(w):
                    return self.rhs_sce_dirac(w, adim=True) - w
                sce = sce_dirac
                w_lim = w_min+30*self.b if w_lim is None else w_lim
            # compute and return
            try:
                w_star = brentq(sce, w_min, w_lim)
            except ValueError as e:
                if self._ignore_errors:
                    w_star = np.NaN
                else:
                    raise
        else:
            w_star = np.NaN
            if not self._ignore_errors:
                raise RuntimeError("Parameters lead to stable equilibrium.")
        # the value makes sense only if there are at least two spikes
        if (w_star - w_min) / self.b < 2.:
            w_star = np.NaN
        if synchronous:
            return (w_min + self.b*int(np.ceil((w_star-w_min)/self.b)))*dim
        else:
            return w_star*dim


    def ISI(self, w, model="alpha", I=None, approx=False, adim=False):
        '''
        Inter-spike interval during the burst (time between two consecutive
        spikes.

        Args:
            w (double): Value of the adaptation variable.
            model (:obj:`str`, optional, default: "alpha"): Synaptic model.
            I (double, optional, default: None): Value of the input current
                (required for the continuous model only).
            adim (bool, optional, default: False): Whether the result is should
                be dimensionned or not.
        '''
        if not adim:
            w /= self.dimW
            if I is not None:
                I /= self.dimW
        if model == "alpha":
            return self.T_spike_alpha(w, adim=adim)
        elif model == "continuous":
            return (self.T_spike_continuous_approx(w, I, adim) if approx
                    else self.T_spike_continuous(w, I, adim))
        else:
            return self.T_spike_dirac(w, adim)


    def IBI(self, w_max=None, model="alpha", adim=False):
        '''
        Function returning the value of the interburst interval.

        Args:
            w_max (double, optional, default: None): Maximum value of the
                adaptation variable at the end of the burst (given by the
                self-coherent equation). If ``None``, will be computed using
                the model given by the `model` parameter.
            model (:obj:`str`, optional, default: "alpha"): Model to use in
                order to compute `w_max` if ``None`` is provided.
            adim (bool, optional, default: True): Whether the result return is
                dimensionless or not
        '''
        if w_max is None:
            if self._computed:
                dim = 1. if adim else self.dimT
                return dim*self._res["IBI"]
            else:
                w_max = self.w_max(model=model, adim=adim)
        if not adim:
            w_max /= self.dimW
        # First compute the time necessary for the sharp decrease of V
        V_max = self.V_end_burst(w_max, model=model, adim=True)
        Tdown = self.T_down(w_max, model=model, adim=True)
        V_min = self.V_down(w_max, V_max, Tdown, adim=True)
        w_down = self.w_down(w_max, model=model, adim=True)
        T_start_recov = self.T_start_recover(V_min, w_down, adim=True)
        wmin = self.w_minus(adim=True)
        wmin0 = 1. + self.EL + self.Ie
        w_recov_start = self.w_recover_start(
            T_start_recov, w_down, V_min, adim=True)
        # Then compute the time necessary for `w` to decay to w_min
        cst = self.a*self.Ie/(1.+self.a)
        arg_log = (w_recov_start-cst)/((wmin+wmin0)/2.-cst)
        T_recov = (self.tw-self.a) * np.log(arg_log) / (1.+self.a)
        # duration of the first spike
        V_recov_start = self.V_recover_start(
            T_start_recov, w_down, V_min, adim=True)
        V_end_recov = self.V_recover_lin(
            wmin0, w_recov_start, wmin, V_recov_start, adim=True)
        T_fs = self.T_first_spike(V_end_recov, adim=True)
        # sum all
        IBI = Tdown + T_recov + T_start_recov + T_fs
        return IBI if adim else IBI * self.dimT


    def w_minus(self, adim=False):
        ''' Minimum value reached by w just before burst initiation. '''
        w_min = (self.tw*self.Ie - (self.a-self.tw)*self.EL)/(self.tw + 1.)
        return w_min if adim else w_min*self.dimW


    def V_down(self, w_max, V_max, Tdown=None, adim=False):
        ''' Minimum value reached by V quickly after burst termination. '''
        if not adim:
            V_max = (V_max - self.Vt_dim) / self.DT_dim
            w_max /= self.dimW
        t = (self.T_down(w_max, V_init=V_max, adim=True)
             if Tdown is None else Tdown)
        Vmin0 = self.V_min0(w_max)
        beta = self.EL + self.Ie - w_max
        dotw0 = (0.5*self.a*(Vmin0 + V_max - 2*self.EL) - w_max) / self.tw
        alpha = V_max - beta - dotw0
        V_down = alpha*np.exp(-t) + dotw0*(1-t) + beta
        return V_down if adim else V_down*self.DT_dim + self.Vt_dim

    def SpB(self, w_max=None, model="alpha", adim=False):
        ''' Return the number of spikes in a burst. '''
        if w_max is not None:
            w_max = w_max if adim else w_max / self.dimW
        else:
            if not self._computed:
                self.compute_properties(model=model)
            w_max = self._res["w_max"]
            if not adim:
                w_max *= self.dimW
        w_min = self.w_minus(adim=adim)
        if not (w_max > 0 and w_min > 0):
            if self._ignore_errors:
                return np.NaN
            else:
                raise RuntimeError("Null/negative `w_max` and/or `w_min`.")
        return int(np.ceil((w_max - w_min) / self.b))

    def burst_duration(self, model="alpha", adim=False):
        ''' Return the duration of a burst. '''
        dim = 1. if adim else self.dimT
        if not self._computed:
            self.compute_properties(model=model)
        if not (self._res["ISI"] > 0 and self._res["SpB"] > 1):
            if self._ignore_errors:
                return np.NaN
            else:
                raise RuntimeError("Null or negative `ISI` or `SpB` <= 1.")
        return self._res["ISI"]*(self._res["SpB"]-1)*dim

    #---------------------------------------------------------------------------
    # Self-coherent equations (right-hand sides)

    def rhs_sce_alpha(self, w, adim=False):
        '''
        Right-hand side of the self-coherent equation for w in the alpha model.
        '''
        w_tmp = w
        if not adim:
            w_tmp = w/self.dimW if isinstance(w, float) else w.copy()/self.dimW
        w_min = self.w_minus(adim=True)
        cst = self.EL + self.Ie - self.Vr
        cst2 = self.c*self.k*np.e*self.ts
        if isinstance(w, float):
            if np.isclose(w, w_min):
                w_tmp = np.nextafter(w_min, w_min+1.)
        else:
            w_tmp[np.isclose(w_tmp, w_min)] = np.nextafter(w_min, w_min+1.)
        # test
        shift = self.EL + self.Ie - w_tmp
        Vd = shift + (self.Vr - shift)*np.exp(-self.d)
        # between d and d+4\tau_s
        I = self.c*self.k*np.e / 4.
        V_int =  Vd + 4*self.ts*(self.Ie + I -Vd + self.EL - w_tmp)
        LW = np.real(lambertw(-np.exp(shift), -1))
        DT, Vth = self._prop["Delta_T"], self._prop["V_th"]
        rhs = cst + np.exp(self.d)*(LW + cst2)/(4*self.ts-1)
        return rhs if adim else rhs*self.dimW

    def rhs_sce_dirac(self, w, adim=False):
        '''
        Right-hand side of the self-coherent equation for w in the alpha model.
        '''
        w_tmp = w
        if not adim:
            w_tmp = w/self.dimW if isinstance(w, float) else w.copy()/self.dimW
        w_min = self.w_minus(adim=True)
        cst = self.EL+self.Ie-self.Vr
        if isinstance(w, float):
            if np.isclose(w, w_min):
                w_tmp = np.nextafter(w_min, w_min+1.)
        else:
            w_tmp[np.isclose(w_tmp, w_min)] = np.nextafter(w_min, w_min+1.)
        LW = np.real(lambertw(-np.exp(self.EL+self.Ie-w_tmp), -1))
        rhs = cst-np.exp(self.d)*(self.k*self.Qs + LW)
        return rhs if adim else rhs*self.dimW

    def rhs_sce_continuous(self, w, adim=False):
        '''
        Right-hand side of the self-coherent equation for w in the alpha model.
        '''
        w_tmp = w
        if not adim:
            w_tmp = (w / self.dimW if isinstance(w, float)
                     else np.divide(w, self.dimW))
        w_min = self.w_minus(adim=True)
        if isinstance(w, float):
            if np.isclose(w, w_min):
                w_tmp = np.nextafter(w_min, w_min+1.)
        else:
            w_tmp[np.isclose(w_tmp, w_min)] = np.nextafter(w_min, w_min+1.)
        I_plus = w_tmp + self.Ie - w_min
        avg_isi = self.avg_ISI(w_tmp, model="continuous", I=I_plus, adim=True)
        rhs = w_min + self.b * (avg_isi - self.d) + self.k*self.Qs
        return rhs if adim else rhs*self.dimW

    #--------------------------------------------------------------------------
    # Interpike intervals

    def T_spike_dirac(self, w, adim=True):
        ''' Compute the spike time for the Dirac synapse. '''
        ww = w if adim else np.divide(w, self.dimW)
        # between 0 and d
        Vd = self.V_lin_alpha_psp(self.d, ww, adim=adim)
        # after d
        A = self.EL + self.Ie - ww
        B = np.exp(self.Vp) + A/2.
        G = np.exp(Vd + self.k*self.c*self.Qs) + A/2.
        time = self.d + np.log((G+A/2.)*(B-A/2.)/((G-A/2.)*(B+A/2.)))/A
        if time < 0 and not self._ignore_errors:
            raise ValueError("Negative ISI for Dirac model.")
        else:
            time = np.NaN if time < 0 else time
        return time if adim else time*self.dimT

    def T_spike_continuous(self, w, I, adim=True):
        ''' Compute the spike time for the continuous synapse. '''
        ww = w if adim else np.divide(w, self.dimW)
        II = I if adim else np.divide(I, self.dimW)
        time = quad(
            _plib.invDerivV, self.Vr, self.Vp,
            args=(ww, self.EL, self.Ie, II))[0]
        if time < 0 and not self._ignore_errors:
            raise ValueError("Negative ISI for continuous model.")
        else:
            time = np.NaN if time < 0 else time
        return time if adim else time*self.dimT

    def T_spike_continuous_approx(self, w, I, adim=True):
        ''' Approximate spike time for the continuous synapse. '''
        ww = w if adim else np.divide(w, self.dimW)
        II = I if adim else np.divide(I, self.dimW)
        A = self.EL + II - ww
        B = np.exp(self.Vp) + A/2.
        time = np.log(np.abs( (self.Vr-self.EL-II+ww)/(ww-self.EL-II) )) +\
               1./A*np.log( np.abs( (1.+A)*(B-A/2.)/(B+A/2.) ) )
        if time < 0 and not self._ignore_errors:
            raise ValueError("Negative ISI for continuous approximation.")
        else:
            time = np.NaN if time < 0 else time
        return time if adim else time*self.dimT

    def T_spike_alpha(self, w, delay=None, adim=False):
        '''
        Compute the spike time for the simplified (squared) alpha synapse.

        Args:
            w (double): Value of the adaptation variable (should be in pA if
                `adim` is ``False``, otherwise dimensionless.
            adim (bool, optional, default: False): Whether the returned result
                should be dimensionless or not.
        '''
        ww = w if adim else np.divide(w, self.dimW)
        dd = self.d
        if delay is not None:
            dd = delay if adim else delay / self.dimT
        # between 0 and d
        shift = self.EL + self.Ie - ww
        Vd = shift + (self.Vr - shift)*np.exp(-dd)
        # between d and d+4\tau_s
        I = self.c*self.k*np.e / 4.
        V_int =  Vd + 4*self.ts*(self.Ie + I - Vd + self.EL - ww)
        time = dd + 4*self.ts
        # divergence time
        A = self.EL + self.Ie - ww - V_int
        B = np.exp(self.Vp) + A/2.
        G = np.exp(V_int) + A/2.
        if V_int > 0:
            time += np.log(np.abs((2*G+A)*(2*B-A)/((2*G-A)*(2*B+A))))/A
        else:
            time += np.log((A-V_int)/A) +\
                    np.log(np.abs((1+A)*(2*B-A)/(2*B+A)))/A
        if time < 0 and not self._ignore_errors:
            raise ValueError("Negative ISI for alpha model.")
        else:
            time = np.NaN if time < 0 else time
        return time if adim else time*self.dimT

    def avg_ISI(self, w_max=None, model="alpha", I=None, adim=False):
        '''
        Average inter-spike interval during the burst.

        Args:
            w_max (double): Maximum value of the adaptation variable.
            model (:obj:`str`, optional, default: "alpha"): Synaptic model.
            I (double, optional, default: None): Value of the input current
                (required for the continuous model only).
            adim (bool, optional, default: False): Whether the result should be
                dimensionned or not.
        '''
        if w_max is None:
            if self._computed:
                dim = 1. if adim else self.dimT
                return dim*self._res["IBI"]
            else:
                w_max = self.w_max(model=model, adim=adim)
        if not adim:
            w_max /= self.dimW
        w_min = self.w_minus(adim=True)
        #~ wmax = w_max - self.b
        w = w_min
        avg_ISI = 0.
        num_spikes = 0
        approx = False # necessary for continuous
        while w < w_max:
            avg_ISI += self.ISI(w, model, I, approx, adim)
            w += self.b
            num_spikes += 1
        avg_ISI = avg_ISI / num_spikes if num_spikes else np.NaN
        return avg_ISI*(1. if adim else self.dimT)

    def T_first_spike(self, V_init, adim=False):
        if not adim:
            V_init = (V_init - self.Vt_dim) / self.DT_dim
        wmin = self.w_minus(adim=True)
        wmin0 = 1. + self.EL + self.Ie
        w_avg = (wmin + wmin0) / 2.
        A = self.EL + self.Ie - w_avg
        B = np.exp(self.Vp) + A/2.
        T_fs = np.log(np.abs((V_init - self.EL + w_avg) / (w_avg - self.EL)))\
               + np.log(np.abs((1. + A)*(B - A/2.)/(B + A/2.))) / A
        if T_fs < 0 and not self._ignore_errors:
            raise ValueError("Negative time for first spike initiation")
        else:
            T_fs = np.NaN if T_fs < 0 else T_fs
        return T_fs if adim else T_fs*self.dimT

    #--------------------------------------------------------------------------
    # Various functions

    def V_unstab(self, adim=False):
        return 0. if adim else self.Vt_dim

    def w_down(self, w_max, V_init=None, model="alpha", adim=False):
        if not adim:
            w_max /= self.dimW
        t = self.T_down(w_max, V_init=V_init, model=model, adim=True)
        Vmin0 = self.V_min0(w_max)
        dotw0 = (0.5*self.a*(Vmin0+self.Vr-2*self.EL)-w_max)/self.tw
        return w_max+dotw0*t if adim else (w_max+dotw0*t)*self.dimW

    def w_recover_lin(self, V, adim=False):
        '''
        Return the value of w during the recovery period as a function of the
        potential.
        This value is obtained as the limit where $\dot{w} = -\dot{V}$ and
        follows:
        $$w = \frac{1}{1+\tau_w} \left[ (a-\tau_w)(V-E_L)+\tau_w I_e \right]$$
        '''
        if not adim:
            V = (V - self._prop["V_th"])/self._prop["Delta_T"]
        dim = 1. if adim else self.dimW
        return ((self.a-self.tw)*(V-self.EL)+self.tw*self.Ie)/(1.+self.tw)*dim

    def V_recover_lin(self, w, w_init, w_min, V_min, adim=False):
        '''
        Return the value of V during the beginning of the recovery period as a
        function of the potential.
        This value is obtained as the limit where $\dot{w} = -\dot{V}$ and
        follows:
        $$w = \frac{1}{1+\tau_w} \left[ (a-\tau_w)(V-E_L)+\tau_w I_e \right]$$
        '''
        if not adim:
            w_min /= self.dimW
            V_min = (V_min - self.Vt_dim) / self.DT_dim
            w /= self.dimW
            w_init /= self.dimW
        V = V_min * ( 1 - (w - w_init)/(w_min - w_init) )
        return V if adim else V*self.DT_dim + self.Vt_dim

    def V_min0(self, wmax):
        ''' Dimensionless minimum for V at zeroth order '''
        return self.EL + self.Ie - wmax

    def T_down(self, w_max, V_init=None, model="alpha", adim=False):
        V_final = (self.V_end_burst(w_max, model, adim=True) if V_init is None
                   else V_init)
        if not adim:
            w_max /= self.dimW
        V_min0 = self.V_min0(w_max)
        T_down = np.log(1. + 2*self.tw*(V_final + V_min0) /
                        (self.a*(self.Ie+V_final-self.EL) - (2.+self.a)*w_max))
        return T_down if adim else T_down*self.dimT

    def w_recover_start(self, t, w_down, V_min, adim=False):
        t_tmp = t
        if not adim:
            t_tmp = np.divide(t, self.dimT)
            V_min = (V_min - self.Vt_dim) / self.DT_dim
            w_down /= self.dimW
        B = self.a*(V_min - self.EL)
        w = B + (w_down - B)*np.exp(-t_tmp/self.tw)
        return w if adim else w*self.dimW

    def V_recover_start(self, t, w_down, V_min, adim=False):
        t_tmp = t
        if not adim:
            t_tmp = np.divide(t, self.dimT)
            V_min = (V_min - self.Vt_dim) / self.DT_dim
            w_down /= self.dimW
        B = self.a*(V_min - self.EL)
        ratio = self.tw/(self.tw - 1)
        V = V_min + (B - w_down)*(-(ratio - 1)*np.exp(-t_tmp) - 1
            + ratio*np.exp(-t_tmp/self.tw))
        return V if adim else V*self.DT_dim + self.Vt_dim

    def V_end_burst(self, w, model="alpha", return_time=False, adim=False):
        if not adim:
            w /= self.dimW
        V_final, t_final = 0., 0.
        if model == "dirac":
            V_final = (self.Vr-self.Ie-self.EL+w)*np.exp(-self.d) + self.EL\
                      + self.Ie - w + self.k*self.Qs
            t_final = self.d
        elif model == "alpha":
            # get the maximum of V_lin_alpha if it's less than 3 delays,
            # otherwize the last value will be a good approximation anyway.
            ts, Vs = self._func_V_spike(w, stop=3.*self.d, adim=True)
            try:
                idx_max = np.nanargmax(Vs)
                V_final, t_final = Vs[idx_max], ts[idx_max]
            except ValueError as e:
                if self._ignore_errors:
                    if self.verbose:
                        print(e)
                    V_final, t_final = np.NaN, np.NaN
                else:
                    raise
        else:
            V_final = self.Vr
        if return_time:
            if adim:
                return V_final, t_final
            else:
                return V_final*self.DT_dim + self.Vt_dim, t_final*self.dimT
        else:
            return V_final if adim else V_final*self.DT_dim + self.Vt_dim

    def T_start_recover(self, V_min, w_down, adim=False):
        ''' Time necessary to reach $w_{r, L}(V_{min})$ '''
        if not adim:
            V_min = (V_min - self.Vt_dim) / self.DT_dim
            w_down /= self.dimW
        B = self.a*(V_min - self.EL)
        w_target = self.w_recover_lin(V_min, adim=True)
        T = self.tw*np.log((w_down-B)/(w_target-B))
        if T < 0 and not self._ignore_errors:
            raise ValueError("Negative time for beginning of recovery.")
        else:
            T = np.NaN if T < 0 else T
        return T if adim else T*self.dimT

    def V_lin_alpha_psp(self, t, w, adim=False):
        '''
        Return the potential between two spikes in the burst.
        This function uses a local time which is zero at spike time.

        warning:
            This function is not supposed to be used with arrays! (except by
            _func_V_spike).
        '''
        Vs = None
        if not adim:
            w /= self.dimW
            t /= self.dimT
        frac_ts = self.ts/(self.ts-1)
        shift = self.EL + self.Ie - w
        Dt = self.T_spike_alpha(w, adim=True) - self.d
        t0 = t if (isinstance(t, float) or isinstance(t, int)) else t[-1]
        if t0 <= self.d:
            decay = ( self.Vr - shift )*np.exp(-t)
            psp = self.I0*frac_ts*( np.exp(-Dt/self.ts-t)*(frac_ts-Dt) +\
                                    np.exp(-(t+Dt)/self.ts)*(Dt+t-frac_ts) )
            Vs = shift + decay + psp
        else:
            t1 = t if (isinstance(t, float) or isinstance(t, int)) else t[0]
            assert t1 >= self.d, '''Times must be either all smaller or all
                larger than the delay.'''
            tt = np.array(t - self.d)
            Vd = shift + ( self.Vr - shift )*np.exp(-self.d) +\
                 self.I0*frac_ts*( np.exp(-Dt/self.ts-self.d)*(frac_ts-Dt) +
                              np.exp(-(self.d+Dt)/self.ts)*(Dt+self.d-frac_ts) )
            decay = ( Vd - shift )*np.exp(-tt)
            Dt1 = Dt + self.d
            psp1 = self.I0*frac_ts*( np.exp(-Dt1/self.ts-tt)*(frac_ts-Dt1) +\
                                    np.exp(-(tt+Dt1)/self.ts)*(Dt1+tt-frac_ts) )
            psp2 = self.I0*frac_ts*(np.exp(-tt)*frac_ts +
                                    np.exp(-tt/self.ts)*(tt-frac_ts) )
            Vs = shift + decay + psp1 + psp2
        if not adim: # changed the reference if t is a numpy array
            t *= self.dimT
        return Vs if adim else Vs*self.DT_dim + self.Vt_dim

    #---------------------------------------------------------------------------
    # Detailed functions

    def _func_V_spike(self, w, steps=1000., start=0., stop=None, model="alpha",
                      adim=False):
        ''' Return the potential between two spikes in the burst. '''
        if not adim:
            start /= self.dimT
        if stop is None:
            stop = self.ISI(w, model, adim=True)
        # generate the times and check whether the delay is included inside
        ts = np.linspace(start, stop, steps)
        idx_d = find_idx_nearest(ts, self.d)
        if idx_d >= len(ts)-2: # to make sure idx_d+1 works and is after d
            if not adim:
                ts *= self.dimT
            return ts, self.V_lin_alpha_psp(ts, w, adim=adim)
        else:
            if not adim:
                ts *= self.dimT
            idx_lim = np.where(ts[idx_d-1:] > self.d)[0][0] + idx_d - 1
            pre_d = self.V_lin_alpha_psp(ts[:idx_lim], w, adim=adim)
            post_d = self.V_lin_alpha_psp(ts[idx_lim:], w, adim=adim)
            return ts, np.concatenate((pre_d, post_d))

    def _func_Vdown(self, w_max, V_max, steps, start=0, stop=None,
                    adim=False):
        '''
        Function giving the potential between `start` and `stop` (by default, 0
        and T_min)

        Args:
            w_max (double):
                Maximum value of w_max at the end of the burst.
            V_max (double):
                Maximum value of the potential after the last spike of the burst.
            steps (int):
                Number of values ot interpolate the function.
            start (double, optional, default: 0.)
                Starting time (by default, its is the end of the burst, defined as
                zero time)
            stop (double):, optional (default: None)
                End time, if None, defaults to T_down

        Returns:
            ts, Vs : tuple of numpy arrays for the times and potentials.
        '''
        if not adim:
            V_max = (V_max - self.Vt_dim) / self.DT_dim
            w_max /= self.dimW
            start /= self.dimT
        Vmin0 = self.V_min0(w_max)
        beta = self.EL + self.Ie - w_max
        dotw0 = (0.5*self.a*(Vmin0 + V_max - 2*self.EL) - w_max) / self.tw
        alpha = V_max - beta - dotw0
        if stop is None:
            stop = start + self.T_down(w_max, V_init=V_max, adim=True)
        elif not adim:
            stop /= self.dimT
        ts = np.linspace(start, stop, steps)
        Vs = alpha*np.exp(start-ts) + dotw0*(1+start-ts) + beta
        if adim:
            return ts, Vs
        else:
            return self.dimT*ts, self.DT_dim*Vs + self.Vt_dim

    def _func_wdown(self, w_max, V_max, steps, start=0., stop=None,
                    adim=False):
        '''
        Function giving w between `start` and `stop`, which are defined by
        default as 0. and $T_{min}$.

        Args:
        w_max (double):
            Maximum value of w_max at the end of the burst.
        V_max (double):
            Maximum value of the potential after the last spike of the burst.
        steps (int):
            Number of values ot interpolate the function.
        start (double):
            Starting time.
        stop (double):, optional (default: None)
            End time, if None, defaults to T_down

        Returns:
        ts, ws : tuple of numpy arrays for the times and values of w
        '''
        if not adim:
            V_max = (V_max - self.Vt_dim) / self.DT_dim
            w_max /= self.dimW
            start /= self.dimT
            if not isinstance(steps,int):
                steps = np.divide(steps, self.dimT)
        Vmin0 = self.V_min0(w_max)
        beta = self.EL + self.Ie - w_max
        dotw0 = (0.5*self.a*(Vmin0 + V_max - 2*self.EL) - w_max) / self.tw
        alpha = V_max - beta - dotw0
        if stop is None:
            stop = start + self.T_down(w_max, V_init=V_max, adim=True)
        elif not adim:
            stop /= self.dimT
        ts = (np.linspace(start, stop, steps) if isinstance(steps, int)
              else steps)
        ws = w_max + dotw0*(ts - start)
        if adim:
            return ts, ws
        else:
            return self.dimT*ts, self.dimW*ws

    def _func_w_recover_start(self, w_down, w_max, V_max, start=None,
                              stop=None, adim=False):
        '''
        Dynamics of w during the early phase of the recovery period, just after
        the decrease of V.
        '''
        if not adim:
            w_down /= self.dimW
            w_max /= self.dimW
            V_max = (V_max - self.Vt_dim) / self.DT_dim
        V_min = self.V_down(w_max, V_max, adim=True)
        if start is None:
            start = self.T_down(w_max, V_init=V_max, adim=True)
        elif not adim:
            start /= self.dimT
        if stop is None:
            stop = start + self.T_start_recover(V_min, w_down, adim=True)
        elif not adim:
            stop /= self.dimT
        ts = np.linspace(start, stop, 200)
        ws = self.w_recover_start(ts-start, w_down, V_min, adim=True)
        if adim:
            return ts, ws
        else:
            return ts*self.dimT, ws*self.dimW

    def _func_V_recover_start(self, ts, w_down, w_max, V_max, adim=False):
        ts_tmp = np.array(ts) - ts[0]
        V_min = self.V_down(w_max, V_max, adim=adim)
        return self.V_recover_start(ts_tmp, w_down, V_min, adim=adim)

    def _func_w_recover(self, w_init, V_init, w_max, V_max, steps, start=None,
                        stop=None, adim=False):
        '''
        Function giving w between `start` and `stop` (by default, T_min and
        T_I) during the recovery period -- after the sharp decrease of V.

        Args:
        w_init (double):
            Maximum value of w_max at the end of the burst.
        V_init (double):
            Maximum value of the potential after the last spike of the burst.
        steps (int):
            Number of values ot interpolate the function.
        start (double):, optional (default: 0.)
            Starting time (by default, its is the end of the burst, defined as
            zero time)
        stop (double, optional, default: None): End time, if None, defaults to
            T_down

        Returns:
        ts, ws : tuple of numpy arrays for the times and values of w
        '''
        if not adim:
            w_init /= self.dimW
            V_init = (V_init - self.Vt_dim) / self.DT_dim
            V_max = (V_max - self.Vt_dim) / self.DT_dim
            w_max /= self.dimW
        V_min = self.V_down(w_max, V_max, adim=True)
        w_down = self.w_down(w_max, V_init=V_max, adim=True)
        cst = self.a*self.Ie/(1.+self.a)
        ratio = (self.tw-self.a) / (1.+self.a)
        T_down = self.T_down(w_max, V_init=V_max, adim=True)
        T_start_recov = self.T_start_recover(V_min, w_down, adim=True)
        if start is None:
            start = T_down + T_start_recov
        elif not adim:
            start /= self.dimT
        if stop is None:
            stop = start + self.IBI(w_max, adim=True) - T_down - T_start_recov
        elif not adim:
            stop /= self.dimT
        ts = np.linspace(start, stop, steps)
        ws = cst + (w_init - cst) * np.exp(-(ts - start) / ratio)
        if adim:
            return ts, ws
        else:
            return self.dimT*ts, self.dimW*ws

    def _func_V_recover(self, ws, V_init, adim=False):
        '''
        Function giving V during the recovery period -- after the sharp
        decrease of V to $V_-$ -- as a function of w.

        Args:
            ws (:obj:`list`): List of the values of w during this period.
            V_init (double): Value of V at the beginning of the recovery (after
                the initial post-burst decrease and nullcline crossing).
            adim (bool, optional, default: True): Whether the input and results
                are dimensionless.

        Returns:
            Vs (:class:`numpy.array`): V values (one for each value in `ws`).
        '''
        if not adim:
            ws = np.divide(ws, self.dimW)
            V_init = (V_init - self.Vt_dim) / self.DT_dim
        idx_nan = np.where(ws < (self.EL + self.Ie + 1.))
        w_min = self.w_minus(adim=True)
        #~ Vs = V_init * ( 1 - (ws-ws[0])/(ws[-1]-ws[0]) )
        Vs = self.V_recover_lin(ws, ws[0], w_min, V_init, adim=True)
        Vs[idx_nan] = np.NaN
        return Vs if adim else Vs*self.DT_dim + self.Vt_dim

    def _func_w_burst(self, w_min, t_init, steps, model="alpha",
                      synchronous=False, adim=False):
        '''
        Function giving the behaviour of w during the burst.

        Args:
            w_min (double): Initial value of w at the beginning of the burst.
            t_init (double): Time at which the first spike of the burst occurs.
            steps (int): Number of points to interpolate the function.
            model (:obj:`str`, optional, default: "alpha"): Model used for the
                PSPs ("dirac", "continuous", or "alpha").

        Returns:
            ts, ws (:class:`numpy.array`s): Times and values of w during the
                burst.
        '''
        if not adim:
            w_min /= self.dimW
            t_init /= self.dimT
        w, ISI = w_min + self.b, 0.
        # initialize spike and w lists
        spike_times, lst_w = [0.], [w]
        ts, ws = None, np.zeros(steps)
        # compute the critical value of w and the number of spikes
        w_star = self.w_max(model=model, synchronous=synchronous, adim=True)
        if np.isnan(w_star):
            raise RuntimeError("NaN value for w_star")
        SpB = self.SpB(w_star, adim=True)
        # compute the spike times and w_max
        for i in range(SpB-1):
            w = min(w + self.b, w_star)
            I = None if model != "continuous" else self.Ie + w_star - w_min
            ISI = self.ISI(w, model=model, I=I, adim=True)
            spike_times.append(spike_times[-1] + ISI)
            lst_w.append(w)
        # deduce the duration of the burst
        T_B = spike_times[-1]
        # Make the the w values
        lst_w = lst_w[::-1]
        if T_B:
            indices = list(np.multiply(steps/T_B,
                                       spike_times).astype(int))[::-1]
            ts = np.linspace(t_init, T_B+t_init, steps)
            if synchronous:
                while indices:
                    idx_start, idx_stop = indices.pop(), 0
                    w_val = lst_w.pop()
                    if indices:
                        idx_stop = indices[-1]
                        ws[idx_start:idx_stop] = w_val
                    else:
                        if idx_start <= len(ws) - 1:
                            ws[idx_start:] = w_val
                        else:
                            ws[-1] = w_val
            else:
                ws = w_min + (ts - t_init)*(w_star - w_min) / (ts[-1] - t_init)
        else:
            ts = np.linspace(0, 1+1./steps, steps)
            ws = np.repeat(w_min, len(ts))
            ws[-1] = w
        if adim:
            return ts, ws, spike_times
        else:
            return (ts*self.dimT, ws*self.dimW,
                    np.multiply(spike_times, self.dimT))

    #--------------------------------------------------------------------------
    # Init tools

    def _generate_values(self, di_prop):
        ''' Store the values from a ``dict`` of dimensionless values. '''
        self.EL = di_prop["E_L"]
        self.Ie = di_prop["I_e"]
        self.ts = di_prop["tau_syn_ex"]
        self.tw = di_prop["tau_w"]
        self.Vr = di_prop["V_reset"]
        self.Vp = di_prop["V_peak"]
        self.a = di_prop["a"]
        self.b = di_prop["b"]
        self.gL = di_prop["g_L"]
        self.DT = di_prop["Delta_T"]
        self.c = di_prop["weight"]
        self.k = di_prop["avg_deg"]
        self.d = di_prop["delay"]
        self.Imax = self.k*self.c
        self.I0 = self.Imax*np.e/self.ts
        self.Vlim = np.log(self.Imax / 2.)
        self.Qs = np.e*self.c*self.ts
